"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.connect = void 0;
const spi_device_1 = __importDefault(require("spi-device"));
const util_1 = require("util");
const mcp3xxx_config_1 = require("./mcp3xxx-config");
const mcp_3xxx_1 = require("./types/mcp-3xxx");
const sleep = util_1.promisify(setTimeout);
const _validateKind = (kind) => {
    if (mcp_3xxx_1.McpKinds.indexOf(kind) === -1)
        throw new Error(`Expected one of: ${mcp_3xxx_1.McpKinds.join(", ")}, received ${kind}`);
};
const _validateChannel = (kind, channel) => {
    var _a;
    if (channel > mcp3xxx_config_1.McpConfigurations[kind].channelCount || channel < 0)
        throw new RangeError(`Expected a channel between 0 and ${(_a = mcp3xxx_config_1.McpConfigurations[kind]) === null || _a === void 0 ? void 0 : _a.channelCount}`);
};
const makeSpiMessage = (channel, config, options) => [
    {
        byteLength: config.transferLength,
        sendBuffer: config.readChannelCommand(channel),
        receiveBuffer: Buffer.alloc(config.transferLength),
        speedHz: (options === null || options === void 0 ? void 0 : options.speed) || config.defaultSpeed,
    },
];
const sendSpiMessage = (device, message, config) => new Promise((resolve, reject) => {
    device.transfer(message, (error, message) => {
        if (error)
            reject(error.message);
        if (!message[0].receiveBuffer)
            reject(`Invalid buffer response ${message}`);
        resolve(config.getValue(message[0].receiveBuffer));
    });
});
const closeSpiDevice = (device) => new Promise((resolveClose, rejectClose) => {
    device.close((error) => {
        if (error)
            rejectClose();
        resolveClose();
    });
});
/**
 * Connect to an MCP3xxx series A/D converter
 *
 * [Click for MCP3008 Datasheet](https://ww1.microchip.com/downloads/en/DeviceDoc/21295d.pdf)
 *
 * @param kind Board type, e.g. "3008"
 * @param channel MCP channel which the analog sensor/device is connected to
 * @param options Override the default MCP `bus` or `speed`
 */
const connect = (kind, channel, options) => new Promise((resolve, reject) => {
    _validateKind(kind);
    _validateChannel(kind, channel);
    const mergedOptions = Object.assign({ bus: 0, speed: 0 }, options);
    const config = mcp3xxx_config_1.McpConfigurations[kind];
    const device = spi_device_1.default.open(mergedOptions.bus, mergedOptions.speed, (error) => {
        if (error)
            reject(error.message);
        resolve({
            read: () => __awaiter(void 0, void 0, void 0, function* () {
                const message = makeSpiMessage(channel, config, Object.assign({}, options));
                return sendSpiMessage(device, message, config);
            }),
            close: () => __awaiter(void 0, void 0, void 0, function* () { return closeSpiDevice(device); }),
        });
    });
});
exports.connect = connect;
